<!DOCTYPE html>
<html lang="en-US" dir="ltr">
<!--********************************************-->
<!--*       Generated from PreTeXt source      *-->
<!--*                                          *-->
<!--*         https://pretextbook.org          *-->
<!--*                                          *-->
<!--********************************************-->
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta name="robots" content="noindex, nofollow">
</head>
<body class="ignore-math">
<div class="solution solution-like">
<h3 class="heading">
<span class="type">Solution</span><span class="space"> </span><span class="codenumber">4.11.1.1</span><span class="period">.</span>
</h3>
<div class="para">I want to start this time by stepping back and look and assign some new names to the entities from the diagram I recreated last time.</div> <figure class="figure figure-like"><div class="image-box" style="width: 80%; margin-left: 10%; margin-right: 10%;"><img src="generated/latex-image/img-session15-ex3-2.svg" role="img" class="contained"></div>
<figcaption><span class="type">Figure</span><span class="space"> </span><span class="codenumber">4.11.2<span class="period">.</span></span><span class="space"> </span>Naming objects in "Iteration and evaluation defined"</figcaption></figure> <div class="para">My reasoning here is that labeling my objects like this will make it a little more clear on what exactly it would mean for our maps to be inverses.  Given the naming used above, I’d need to prove <span class="process-math">\(h \circ g = 1_A\)</span> and <span class="process-math">\(g \circ h = 1_B\text{.}\)</span>  What makes this tricky is that the objects in <span class="process-math">\(A\)</span> are <span class="process-math">\(\mathcal{S}^{\circlearrowright}\)</span>-maps that preserve the structure from <span class="process-math">\(\boxed{\mathbb{N}^{\circlearrowright \sigma} \rightarrow Y^{\circlearrowright \beta}}\)</span> and the objects in <span class="process-math">\(B\)</span> are maps in <span class="process-math">\(\mathcal{S}\)</span> from <span class="process-math">\(\mathbf{1} \rightarrow Y\)</span> that don’t necessarily preserve any structure.</div> <div class="para">Perhaps what I should be doing is thinking of the maps <span class="process-math">\(\mathbb{N}^{\circlearrowright \sigma} \xrightarrow{f} Y^{\circlearrowright \beta}\)</span> as a collection of arrows.  Each arrow needs to have a source point <span class="process-math">\(n\)</span> in <span class="process-math">\(\mathbb{N}\)</span> and a target point <span class="process-math">\(y\)</span> in <span class="process-math">\(Y\text{.}\)</span>  For <span class="process-math">\(f\)</span> to preserve structure, we’d need to have <span class="process-math">\((f \circ \sigma)(n)= (\beta \circ f)(n)\)</span> for every <span class="process-math">\(n\)</span> in <span class="process-math">\(\mathbb{N}\text{.}\)</span>
</div> <div class="para">Our map <span class="process-math">\(g\text{,}\)</span> basically takes advantage of the fact that any map in <span class="process-math">\(\mathbb{N}^{\circlearrowright \sigma} \xrightarrow{f} Y^{\circlearrowright \beta}\)</span> must be defined over the whole domain.  This means that there must have an arrow originating at the point <span class="process-math">\(0\)</span> pointing to some target point <span class="process-math">\(y = f 0\)</span> in <span class="process-math">\(Y\text{.}\)</span>  We can then define <span class="process-math">\(g: A \rightarrow B\)</span> such that for any <span class="process-math">\(f \in A\)</span> we can define <span class="process-math">\(g(f)\)</span> to be the map in <span class="process-math">\(\mathbf{1} \rightarrow Y\)</span> which maps the only element in <span class="process-math">\(\mathbf{1}\)</span> to the point <span class="process-math">\(f 0\)</span> in <span class="process-math">\(Y\text{.}\)</span>
</div> <div class="para">In contrast, our map <span class="process-math">\(h\)</span> takes a map <span class="process-math">\(\mathbf{1} \xrightarrow{y} Y\)</span> and uses it to produce a map in <span class="process-math">\(\mathbb{N}^{\circlearrowright \sigma} \xrightarrow{f} Y^{\circlearrowright \beta}\text{.}\)</span> It does this by applying <span class="process-math">\(\beta\)</span> to <span class="process-math">\(y\)</span> zero or more times, such that <span class="process-math">\(f(n) = \beta^n(y)\)</span> for any <span class="process-math">\(n \in \mathbb{N}\text{.}\)</span> In the case where <span class="process-math">\(n = 0\text{,}\)</span> the map <span class="process-math">\(\beta\)</span> is never applied at all.  It follows that for any <span class="process-math">\(1 \xrightarrow{y} Y\)</span> in <span class="process-math">\(B\text{,}\)</span> we’re guaranteed to have <span class="process-math">\((g \circ h)(y) = g(h(y)) = g(f) = f 0 = \beta^0 y = y\text{.}\)</span>
</div> <div class="para">These two maps both produce maps, but handle structure differently.  The map <span class="process-math">\(g\)</span> takes a map which preserves the structure and uses it to produce a map which might not.  The map <span class="process-math">\(h\)</span> takes a map which may not preserve structure and produces one that does.  The identity <span class="process-math">\((g \circ h)(y) = y\)</span> basically establishes that <span class="process-math">\(g \circ h = 1_B\)</span> in <span class="process-math">\(\mathcal{S}\text{,}\)</span> but I think we still need to establish that the map <span class="process-math">\(h y\)</span> is valid in <span class="process-math">\(\mathcal{S}^{\circlearrowright}\text{.}\)</span>
</div> <div class="para">For any given <span class="process-math">\(y\text{,}\)</span> the map <span class="process-math">\(f = h \circ y\)</span> needs to satisfy <span class="process-math">\((f \circ \sigma)(n) = (\beta \circ f)(n)\)</span> for every <span class="process-math">\(n \in \mathbb{N}\text{.}\)</span> At <span class="process-math">\(n = 0\text{,}\)</span> <span class="process-math">\((f \circ \sigma)(0) = f \sigma 0 = f 1\)</span> and <span class="process-math">\((\beta \circ f)(0) = \beta f 0 = \beta y = f 1\text{.}\)</span> Since <span class="process-math">\((f \circ \sigma)(n) = (\beta \circ f)(n)\)</span> holds true for <span class="process-math">\(n = 0\text{,}\)</span> we can use induction to establish that they must be the same for every ’successor’.</div> <div class="para">Since each <span class="process-math">\(n\)</span> can be represented as <span class="process-math">\(n = \sigma^n 0\text{,}\)</span> we can use that to make a subsitution. If follows that <span class="process-math">\((f \circ \sigma)(n) = (f \circ \sigma)(\sigma^n 0) = f \sigma \sigma^n 0 = f \sigma^{n+1} 0\)</span> and <span class="process-math">\((\beta \circ f)(n) = (\beta \circ f)(\sigma^n 0) = \beta f \sigma^n 0\text{.}\)</span> It also follows that <span class="process-math">\((f \circ \sigma)(n+1) = f \sigma^{n+2} 0\)</span> and <span class="process-math">\((\beta \circ f)(n+1) = \beta f \sigma^{n+1} 0\text{.}\)</span>  Since we know that <span class="process-math">\(f \sigma^{n+1} 0 = \beta f \sigma^n 0\text{,}\)</span> we can combine these two results to establish that <span class="process-math">\((\beta \circ f)(n+1) =  \beta f \sigma^{n+1} 0  = f \sigma \sigma^{n+1} 0 = f \sigma^{n+2} 0  = (f \circ \sigma)(n+1)\text{.}\)</span> Having established that <span class="process-math">\((f \circ \sigma)(0) = (\beta \circ f)(0)\)</span> and <span class="process-math">\((f \circ \sigma)(n) = (\beta \circ f)(n) \implies (f \circ \sigma)(n+1) = (\beta \circ f)(n+1)\text{,}\)</span> <span class="process-math">\(f \circ \sigma = \beta \circ f\)</span> follows by induction.</div> <div class="para">Next, let’s compose these maps in the reverse order to produce the map <span class="process-math">\(h \circ g: A \rightarrow A\text{.}\)</span>  Suppose we have some <span class="process-math">\(\mathbb{N}^{\circlearrowright \sigma} \xrightarrow{f} Y^{\circlearrowright \beta}\)</span> in <span class="process-math">\(A\text{.}\)</span>   It follows from our definitions that that <span class="process-math">\((h \circ g)(f) = h(g(f)) = h(f 0) = h(y) = f\)</span> which would imply that <span class="process-math">\(h \circ g = 1_A\text{.}\)</span>  Having now established that both <span class="process-math">\(h \circ g = 1_A\)</span> and <span class="process-math">\(g \circ h = 1_B\text{,}\)</span> it’s safe to refer to these two maps as inverses.</div> <div class="para">Q.E.D.</div>
</div>
<span class="incontext"><a class="internal" href="session15-p2.html#solution-105">in-context</a></span>
</body>
</html>
